<!-- vscode-markdown-toc -->
* 1. [概論](#概論)
* 2. [原理原則](#原理原則)
  * 2.1. [WEBページとは何か](#webページとは何か)
    * 2.1.1. [HTML](#html)
    * 2.1.2. [CSS](#css)
    * 2.1.3. [JavaScript](#javascript)
  * 2.2. [プログラムとは何か](#プログラムとは何か)
    * 2.2.1. [そもそもコンピュータは何をしているのか](#そもそもコンピュータは何をしているのか)
    * 2.2.2. [プログラマーは何をしているのか、何をしなければいけないのか](#プログラマーは何をしているのか、何をしなければいけないのか)
* 3. [プログラムを書くための予備知識](#プログラムを書くための予備知識)
  * 3.1. [覚えておいた方がいい数学の概念](#覚えておいた方がいい数学の概念)
    * 3.1.1. [集合(set)](#集合(set))
    * 3.1.2. [写像(map)](#写像(map))
    * 3.1.3. [関数(function)](#関数(function))
  * 3.2. [覚えておいた方がいいコンピュータの概念](#覚えておいた方がいいコンピュータの概念)
    * 3.2.1. [変数 (variant)](#変数-(variant))
    * 3.2.2. [関数 (function)](#関数-(function))
    * 3.2.3. [演算子(operator)](#演算子(operator))
    * 3.2.4. [型(type)](#型(type))
    * 3.2.5. [配列(array)](#配列(array))
    * 3.2.6. [連想配列](#連想配列)
* 4. [プログラムを書くための下準備](#プログラムを書くための下準備)
  * 4.1. [node.js](#node.js)
  * 4.2. [Visual Studio Code](#visual-studio-code)
  * 4.3. [Git for Windows](#git-for-windows)
  * 4.4. [プログラム用のフォルダを作る](#プログラム用のフォルダを作る)
* 5. [はじめての node.js](#はじめての-node.js)
  * 5.1. [入れておいた方がいい拡張機能](#入れておいた方がいい拡張機能)
* 6. [はじめてのプログラム](#はじめてのプログラム)
  * 6.1. [Hello World](#hello-world)
  * 6.2. [変数の使いかた](#変数の使いかた)
* 7. [制御構文](#制御構文)
  * 7.1. [関数](#関数)
  * 7.2. [条件分岐](#条件分岐)
  * 7.3. [くりかえし構文(`while`)](#くりかえし構文(`while`))
  * 7.4. [くりかえし構文(`for`)](#くりかえし構文(`for`))
  * 7.5. [くりかえし(`forEach()`)](#くりかえし(`foreach()`))
  * 7.6. [くりかえし(`map()`)](#くりかえし(`map()`))
  * 7.7. [くりかえし(`reduce()`)](#くりかえし(`reduce()`))
  * 7.8. [くりかえし(`for...in`)](#くりかえし(`for...in`))
* 8. [じゃんけんゲーム -設計、実装、テスト、コード管理-](#じゃんけんゲーム--設計、実装、テスト、コード管理-)
  * 8.1. [パッケージ用のディレクトリ作成とコード管理](#パッケージ用のディレクトリ作成とコード管理)
  * 8.2. [外部パッケージのインストールと「管理しないコード」](#外部パッケージのインストールと「管理しないコード」)
  * 8.3. [設計と実装](#設計と実装)
    * 8.3.1. [概要設計](#概要設計)
    * 8.3.2. [入力のうけとりかた](#入力のうけとりかた)
    * 8.3.3. [プログラムを書いていく](#プログラムを書いていく)
    * 8.3.4. [テスト](#テスト)
    * 8.3.5. [テストファーストという考えかた](#テストファーストという考えかた)
    * 8.3.6. [テストを書く](#テストを書く)
    * 8.3.7. [関数の実装](#関数の実装)
    * 8.3.8. [実装を進める上で](#実装を進める上で)

<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc --><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({
 tex2jax: {
 inlineMath: [['$', '$'] ],
 displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
 }
 });
</script>

# ゼロから初めるJavaScripter、或いはフロントエンジニア



##  1. <a name='概論'></a>概論

このコラムではゼロから(本当に「プログラムってなんですか」という状態の人間が)プログラムを、というか俗に言う「フロント分野」と呼ばれる領域の物をとりあえず書けるようになるまでを目的とした *最小限* の事をまとめたコラムである。
本当は「プログラム」についての教材として書こうと思ったが、てっとり早く書ける言語としてJavaScriptを採用したため、ついでならじゃあWEBページぐらい書けるようになったほうがいいよね、という感じでそこまで領域を広げている。

どうやったら最小限になるか筆者も考えながら書いているが、本当に最小限の事しか書かないつもりのため、少しでも学のある者にとってはあの話が足りないこの話が足りないという事が大いにある。
もちろん商用に耐えうる物を書くにはこのコラムに書いてある事だけでは少々足りない。ただまぁ本当に知識が全く無い状態からみてくれの良いWEBページを作るためにはこのぐらい必要だという事については網羅するつもりである。

このページを通読してとりあえずWEBページとは何か、ついでにNode.js(JavaScript)でそれなりのプログラムが書けるようになれば自分で勉強をする「とっかかり」が作れる。
何かを勉強しようとしても何も知らないと何を調べればいいかもわからない。無知の知ならぬ「無知の無知」である。それをとにかく解消するためのコラムだと思って読んで頂ければ幸いである。

##  2. <a name='原理原則'></a>原理原則

この章では2つの事について記述する。「WEBページとは何か」「プログラムとは何か」である。
この2つは最初は別々の物として扱うし、WEBページについての話なんてここで触れたらしばらくでてこない。
それでも原理原則を知っている事は重要で、それは最初に学ぶべきである。正直「フロントエンジニアになるために」なんてブログや教材などいくらでも溢れているが
この原理原則を疎かにしている教材は多い。筆者はこの章が書きたくてこのコラムを書いている様な物である。

###  2.1. <a name='webページとは何か'></a>WEBページとは何か

御存じの通り、ブラウザにURLを入力すると「WEBページ」という物が出てくる。
どういった仕組みでURLからWEBページをひっぱってくるのかは多分最後に説明する。
とにかくWEBページというものは次の3つの要素からできていて、その3つの要素をブラウザが解釈してあんなページやこんなページが表示されるのである。

* HTML
* CSS
* JavaScript

以下一つずつ説明する。

####  2.1.1. <a name='html'></a>HTML

正式名称は「Hyper Text Markup Language」、直訳するなら「装飾された文章を示すための言語」である。これは「文章の構成と構造」をブラウザに伝えるための物である。
「文章の構成と構造」というのは、例えば以下の物が挙げられる。

* ページタイトル
* 見出し
* 子見出し
* 段落
* 箇条書き
* 表

他にも色々あるし、昔はここに「デザイン」も書かれていたが、後述するCSSの登場でその機能は分離された。互換のために今でも書けてしまうのだが、それは絶対にやめた方がいい。

HTMLは「文章の構成と構造」を書く事。現代においてこれは首尾貫徹して守らないといけない物である。

####  2.1.2. <a name='css'></a>CSS

正式名称は「Cascading Style Sheets」、直訳するなら「装飾についての連なった記述」である。単に「スタイルシート」と呼ばれたりする。
「Markup」と「Style」が同じ「装飾」という単語になってしまってややこしいが、「Markup」は「文章の構造を示すための記述」であり後者は文字通りの「装飾」である。
このCSSによって文字に色がついたり大きさが変ったり複雑な配置を表現したりする事ができる。

####  2.1.3. <a name='javascript'></a>JavaScript

ここがいわゆる「プログラム」の部分である。上記二つだけでは静的なページしか表現できない。紙の本と同じである。
この部分に例えば「クリックしたらポップアップが表示される」とか、「現在時刻を表示する」とか、もっと言うと「オセロを表示してプレイできるようにする」とか、そんな事を書いて初めて「動きのある」ページができあがる。
「動的」と書かないのは、そう言ってしまうと例えば「別の場所に個人情報が登録されていてログインができればその人に沿った内容を表示してくれる」とかになってしまうので、とりあえずブラウザだけで完結する領域で留めておく。

余談だが、プログラムに少しでも興味のある人は「Java」という言語がある事を知っているかもしれない。だがこれは全く別の物である。登場した時に既にJavaが有名だったから[それにあやかって付けられただけ](https://ja.wikipedia.org/wiki/JavaScript#%E6%AD%B4%E5%8F%B2)である。全く迷惑な話だ。

###  2.2. <a name='プログラムとは何か'></a>プログラムとは何か

これを一言で説明するのは難しい。意外と文脈によって意味が変ってくる言葉だからだ。あえて説明するなら「コンピュータ(電子機器)に一定の動作をさせるための命令群」である。
パソコンもスマホもファミコンも自動車も全部「プログラム」で動いているのだが、パソコンやスマホなんかを見て「一定」と言われると違和感があるかもしれない。
それは「入力」とか「状態」とかがかかわってくるからなのだが、まぁ後で説明する。

####  2.2.1. <a name='そもそもコンピュータは何をしているのか'></a>そもそもコンピュータは何をしているのか

パソコンやスマホを見ているとなんか色々な事をやっている様に見える。コンピュータというものがメモリとCPUという物で動いているという事は多分知ってる人も多いと思うが、極端な話をすると実はCPUという物は以下の3つしかできない。

* メモリから数字を読み出す
* メモリに数字を書き込む
* 足し算をする

ただしその量がすごい。筆者のパソコンのCPUは「Ryzen 9 5900X」というやつなのだが、こいつは3.7GHzという周波数で動いている。つまり1秒に37億回の足し算ができる。スレッドというものもあって、それが12個並列で走っている。
単純に掛ければ1秒に444億回の足し算ができることになる。まぁ深掘りするとそんな単純な話でもないのだが、とりあえずそう思ってもらえれば大きな支障はない。

####  2.2.2. <a name='プログラマーは何をしているのか、何をしなければいけないのか'></a>プログラマーは何をしているのか、何をしなければいけないのか

プログラマーは何をしているのか。それは「パズルをしている」、というのが筆者が思う最も単純な説明である。
前途の通り、CPUというものは基本的に読み書きと足し算しかできない。けれど、足し算をくりかえせば掛け算ができる。掛け算をくりかえせば累乗の計算ができる。といったようにその限られた機能を使って別の機能を作る事ができる。
その「既にできる事を組み合わせて新しい機能を作る」事をくりかえしていく行為それこそが「プログラミング」であり、その賜物が昨今イメージされる「なにやら珍妙な文章を書けばそれをコンピュータが解釈してくれて書いた通りに動いてくれる」というものでもある。「キーボードを叩けば文章が入力できる」、「書いた文章を解釈してくれる」というのも先人が組み上げた「パズル」であり、我々はその恩恵を存分に享受して簡単にプログラミングという行為を行う事ができるのである。

で、だ。実は、プログラミングをするという行為においてその「なにやら珍妙な文章を書く」事に費やされる時間はそんなに多くない。
その時間の多くは「先人が作った機能を探す」という行為と、「その機能をどう活用するか考える」という行為に費やされる。これが冒頭に「パズルをしている」といった所以である。
つまり我々は何かを作りたいと思った時に、まず「既に作られている物は無いか」というのを探す必要がある。もっと言うと「どういう機能があれば考えている物が作れるのか」を考える必要がある。
もしかしたら作ろうとしてる機能そのものが既に世の中にあるかもしれない。そんな淡い期待を抱きつつGoogleでもなんでも検索をして
そして世の中にその機能が無いと知った時、しかたなく、本当にしかたなくその過程でみつけた断片的な機能を組み合わせて、つまり「なにやら珍妙な文章を書いて」望む機能を作るのである。

よってプログラマーは何をしなければいけないのかという問いの答えは「検索」である。前途の通りまずもってパズルをするためのピースをかき集める事がプログラマーの主たる仕事である。言語の使いかた然り、周辺機能の有無だったり、先人の作った機能然りである。
それらを徹底的に検索し、また見付けた部品を効率よく利用する術をまた検索する。とにもかくにも「検索能力」というものはプログラマーにとって一番大切な能力である。
「プログラマーは怠惰でなければいけない」。既にあるものを作るという行為は、練習のためには良いかもしれないがプログラマーにとって最も無駄であり屈辱的な行為である。

##  3. <a name='プログラムを書くための予備知識'></a>プログラムを書くための予備知識

さて、ここから「じゃあChrome開いてF12押して出てきたところに『1+1』って入力してみ」と運んでも良いのだが、プログラムを書くにあたって知っておいた方がいいものがある。
プログラムに関しての基本的な概念と、数学についての少しの知識である。数学の知識なんていらない、というのは最近の怪しい情報教材や意識高い系のキラキラプログラマーの流行り文句であるがどうせならスマートにプログラムを書きたいしある程度でも知っておけば幅出しも効くので知っておくと便利な事を最初に書いておく。今暫く辛坊されたい。

###  3.1. <a name='覚えておいた方がいい数学の概念'></a>覚えておいた方がいい数学の概念

* 集合(set)
* 写像(map)
* 関数(function)

####  3.1.1. <a name='集合(set)'></a>集合(set)

「モノが集ったもの」である。なんだか身も蓋もない説明であるが、馴染みのある単語を出すなら「整数の集合」とか「素数の集合」とか「実数の集合」とかがある。もちろん数以外のモノが入る可能性もあるし、もっと小さい集合もある。 $\lbrace 0、 1\rbrace$ とか、 $\lbrace 太陽\rbrace$  とか。
とにかく一定の条件だったり特定のモノだったりが集ったもの、それが「集合」である。

####  3.1.2. <a name='写像(map)'></a>写像(map)

「ある集合の要素からある集合へのただひとつへの要素を対応づけるもの」である。同じ集合でもいいし、違う集合でもいい。
例えば「ある実数 $x$ を二乗する」は「実数(の集合)から実数(の集合)への写像」であり、例えば「このテストで30点未満の人は『赤点』、30点以上の人は『合格』とする」というのは「テストの点数(の集合)から合格状況(の集合)への写像」である。

当然「テストの点数」に、例えば「イナゴの佃煮」を入れてはいけない。「イナゴの佃煮」は「テストの点数の集合」に入っておらず、当然イナゴの佃煮に対応する合否は定義されていないからだ。集合の外にあるものに対しての対応は無い。

ここで重要なのは「写像をとった先は一つに定まる」という事である。「この点数は赤点でもあるし合格でもある」という状態があってはいけない。

後述する関数は写像の一種である。

####  3.1.3. <a name='関数(function)'></a>関数(function)

関数という言葉自体は数学で聞いた事があると思うし、 $ f(x)=3x^{2} $ ぐらいの表記は見たことがあると思う。だが先述した「集合」と「写像」の概念があれば、これがただの計算式に留まらないという事が垣間見える。

関数とは写像の具体的な定義である。多少の語弊はあるがまあ許してほしい。とりあえず陽関数の事だけに絞って話をする。つまり「この何かをこうやって新しい何かを作る」というその具体的な内容を定義しているのが「関数」である。適当に例を書くなら $ f(x, y) = (2x, 3y) (x,y \in  \mathbb{R})$ は実数の集合と実数の集合から実数ベクトルへの写像( $ f:\mathbb{R} \times \mathbb{R} \rightarrow \mathbb{R}^2 $ )である。

もっと単純な話をするなら日常よく使う四則演算の類も立派な関数である。つまるところ実数(じゃない時もあるけど)と実数から実数への写像である。いちいち $ p(1,2) $ とか書くのがめんどくさいから $ 1 + 2 $ という書き方が発明された。こういうのを「演算子」という。

###  3.2. <a name='覚えておいた方がいいコンピュータの概念'></a>覚えておいた方がいいコンピュータの概念

ここからプログラムについての話をやっと始める事ができる。プログラムの書きかたを少しずつ説明しながら以下の事について述べていく。興味があればChromeを開いてF12を押せば「コンソール」というものが出てくる。例に挙げたプログラムを実行することができるので、試してみるのもいいかもしれない。

* 変数 (variant)
* 関数(function/数学とは違う概念なので注意)
* 演算子 (operator)
* 型 (type)
* 配列(array)
* 連想配列(なんか色々な名前で呼ばれている)

####  3.2.1. <a name='変数-(variant)'></a>変数 (variant)

「箱」という説明がよくされている。筆者はこの説明があまり好きではないのだがこれ以上に適当な説明が思い浮ばない。ハードウェアアーキテクチャをわかってる人なら「メモリアドレスに紐付いたエイリアス」で通じるのだが、多分わからないと思う。忘れてほしい。

```javaScript
a = 10
```

こう書くと、「a」という変数に10が「入る」。数学で「 `=` 」は「等号」であるが、プログラムにおいては「代入」である。当然これは使い回せる。

```javaScript
a = 10
b = a * 2
```

プログラムは基本的に上に書いた物から解釈されていく。こう書けば「b」という変数に20が入る。ちなみに「*」は掛け算の記号だ。加減乗除は `+-*/` で表現する事ができる。あまり直感に反する物ではないだろう。
とりあえずここではこのぐらいの説明に留めておく。

####  3.2.2. <a name='関数-(function)'></a>関数 (function)

さっきは数学においての関数の話をしたが、これがプログラムになってくると話が変ってくる。
というのも元々は「サブルーチン」と呼ばれていたものが、利便性のため引数という概念を導入した時に数学の関数に似てるから「関数」と呼ばれ始めたからである。

プログラムにおいて「関数」というものは単に「使い回しをするプログラムをくくった物」である。
以下のような感じだ。

```javaScript
f = function(x, y){
    z = x + y
    return z
}

a = f(3, 4)
```

 `function` というのは関数を定義するための接頭語で、そのあとに「引数」となるべき変数を書き、その後実行したい文を書く。最後に `return` として「返却」したい値を書く。

「引数」とは関数に渡す値の事である。その関数の実行された結果として返却される値を「戻り値」と呼ぶ。

`f(3,4)` としているところが実際にその関数を呼び出しているところで、 `x` に3、`y` に4が入って、最終的に `a` には7が入る。

こういう使いかたをしている分には数学の関数と同じような使いかたができる。では次の例はどうだろうか。

```javaScript
console.log("Hello world!")
```

これは「画面(正確には「コンソール」と呼ばれる物)に文字列を表示する」関数だ。返却される値はなにもない。それどころか画面が「汚れる」。これを実行した回数だけ画面には指定した文字列が次々と表示される。

もっとわかりやすい例を示す。

```javaScript
a = 1

console.log(a) // 1 と表示される

incrimentA = function(){
    a = a + 1
    return
}

incrimentA()

console.log(a) // 2 と表示される
```

この関数は引数も持たない。返却するべき値も無い。
ただし実行すると関数の「外」にある変数 `a` に値を入れる。なので関係無い筈の `a` の値が変ってしまう。

こういうふうに関数の外部に影響を及ぼしてしまう関数を「 *副作用を持った* 」関数と呼び、関数の外部にある情報を利用する関数を「 *状態を持った* 」関数と呼ぶ。実際にプログラムを書く上で必要な事なのではあるが、極力副作用や状態を持つ関数というのは作るのを避けた方が無難である。

####  3.2.3. <a name='演算子(operator)'></a>演算子(operator)

先程シレっと「`+`」とか「`*`」とか出したが、これらは「演算子」と呼ばれる物である。
要するに「関数を省略して記号や文字列で書けるようにしたもの」である。
`a+b` と書いたらその裏では `a` と `b` を加算する関数が走っているのである。
プログラム言語には各々様々な演算子が登場するが、出てきた時に説明する。

####  3.2.4. <a name='型(type)'></a>型(type)

さて、変数に入るのは数字だけではない。

```javaScript
str = 'hello world'
```

シングルクォーテーション(`'`)は文字列を記述する時に使う記号だ。こう書けばちゃんと`str`という変数に「文字列」が変数に入る。

```javaScript
str = 'hello world'
console.log(str)
```

こう書けばちゃんと画面に「hello world」と表示される。問題の無い動作だ。
では次の場合はどうだろう。

```javaScript
str = 'hello world'
x = str * 2
```

文字列を掛け算する、など聞いた事が無いだろう。当然このプログラムはエラーを吐く。
このようにプログラムを書く時には「その変数にどんなものが入っているか」を常に気にしなければいけない。
その「どんなもの」を示すのが「型」である。
JavaScriptには以下の型が存在する。

* 数値
  * 数値である。他の言語では「整数」とか「浮動小数」とかが区別されるがJavaScriptにおいては区別されない。だからこそ注意が必要な場面もある。
* 文字列
  * ちなみに他の言語には大抵「文字」があるがJavaScriptには存在しない。文字と数字の関係性は後で説明する。
* 真偽値
  * `true` 、`false` のどちらかをとる値である。つかいかたは追い追い説明する。
* 配列
  * 後述する
* 関数
  * JavaScriptでは関数も立派な型である。関数も変数に代入する事ができる。なんだかややこしい話に思えるが慣れればとても便利である。
* オブジェクト
  * 連想配列
* `undefined`
  * 「定義されていない」事を示す型であり`undefined`という値しか持たない。

実は他にもあるが覚えておけばいいのはこのぐらいである。

さて、少し話を戻す。「関数は写像である」と言ったのを覚えているだろうか。そして「写像とは集合を集合に写すものである」と言ったのを覚えているだろうか。つまるところ「型」とは「集合」を示しているのである。「このテストで30点未満の人は『赤点』、30点以上の人は『合格』とする」と言って、「テストの点数」に「イナゴの佃煮」を入れてはいけない。同じように「`*`」という演算子(関数)に文字列を渡してはいけない。掛け算は数値には定義されているが文字列には定義されていない。

このようにプログラムを書く上で「型」というのは常に意識しなければならず、それは「関数」と密接に結びついている。

####  3.2.5. <a name='配列(array)'></a>配列(array)

値が「並んだ」物である。「値」というのは変数に入るもの全てである。つまり、なんでもいい。

```javascript
arr = [1, 2, 5, 8]
a = arr[2] // a に 5 が入る
```

このように角カッコでくくってカンマで区切れば配列を作る事ができる。取り出す時は番号で取り出す。先頭は「0」なので注意する事。

先程「なんでもいい」と言った。中身は数値じゃなくてもいい、なんならバラバラな型を持っていてもいい。

```javascript
arr = [1, 'hello!', true, [1, 3, 6] ]
a = arr[1] // a に 'hello!' が入る
```

が、このような使いかたはするべきではないし、実際JavaScript以外の殆どの言語では中に入る値の「型」は統一されていなければいけない。配列は値をまとめて取り扱いたい時に用いられる物であるし、例えば「配列の中の全ての値に対してXXをする」という使いかたをするケースも多い。
配列の中には同じ型を持った値を入れる事。異なった性質の物を扱いたい時は後述する「連想配列」を用いる事。

####  3.2.6. <a name='連想配列'></a>連想配列

同じ「配列」という名前が使われているので少しややこしいが、JavaScriptにおいては「オブジェクト」と呼ばれ「メンバ」を持った値である。例えばこんな感じである。

```javascript
obj = {
    value: 10,
    message: 'hello!'
}

console.log(obj.value) // 10と表示される
console.log(obj.message) // hello! と表示される

obj.value = 100

console.log(obj.value) // 100と表示される
```

中括弧(`{}`)で始め、その中に「名前: 値」をカンマで区切って並べる。
この名前のついた中身の事を「メンバ」と呼ぶ。メンバはどんな値を持っていても良い。真偽値でも関数でも、オブジェクトを入れ子にしても良い。

また参照する時にはドット演算子を使って呼び出したり、また直接値を代入したりできる。

ところで何の説明も無しに `console.log` という関数を使っていたが、これも見ての通り `console` というオブジェクトに入った `log` という関数を呼び出している。 `console` というオブジェクトの中には文字通りコンソールに関わる様々な機能がメンバとして登録されている。

##  4. <a name='プログラムを書くための下準備'></a>プログラムを書くための下準備

さて、プログラムを、少なくともJavaScriptを書く上で必要な「概念」をここまで説明した。やっとのであるがプログラムを書いて実行する環境を整えよう。
Windows環境を前提にし、以下の物をインストールする。

###  4.1. <a name='node.js'></a>node.js

JavaScriptというものは本来ブラウザ上で動くだけの物であった。それをOS上で直接動かせるようにするものがnode.jsである。
以下のページでインストーラをダウンロードする事。「推奨版」と書かれている方で良い。

<https://nodejs.org/ja/>

インストールはexeを実行すれば流れでできる。詳細は割愛する。
コマンドプロンプトなりパワーシェルを開いて、以下の入力をしてバージョン情報が表示されれば成功である。

```bash
node --version
```

###  4.2. <a name='visual-studio-code'></a>Visual Studio Code

普通の「メモ帳」とかでプログラムを書くのはまぁしんどい。これは「IDE」というやつでプログラムを書くのに便利な機能が一通り揃っている。拡張機能も充実しているから自分で環境をカスタマイズする事もできる。とにもかくにも以下のページに行ってダウンロードする事。

<https://azure.microsoft.com/ja-jp/products/visual-studio-code/>

こいつもインストールは流れで行える。
途中「右クリックメニューを有効にするか」のチェックマークをつけるところがあるのでそれは絶対に有効にしておいた方がよい。便利である。

###  4.3. <a name='git-for-windows'></a>Git for Windows

「バージョン管理ツール」というやつだ。
以下のページからダウンロードできる。

<https://gitforwindows.org>

途中インストールするソフトの種類を聴かれるので、「Git Bash」にチェックが入っているかを確認する事。基本的にはCLIから操作するものだからだ。

###  4.4. <a name='プログラム用のフォルダを作る'></a>プログラム用のフォルダを作る

さて、作ろうとしているプログラムをどこにおけばいいか。まぁどこでもいいのだが「フルパスが半角英数のみで構成されていてできるだけ短かくなるような場所」に置くとトラブルが少ない。得に日本語環境だと普通の場所に作ろうとすると「ユーザ」とかが入ってくるからややこしいことになる。ここではLinux系列の流儀に従ってフォルダを作ろうと思う。

Cドライブ直下に `home` というフォルダを作ろう。そしてその直下にまた自分の名前でもつけたフォルダを作ろう。勿論半角英数でだ。大文字は使わない方がいい。Windowsファイルシステムでは大文字と小文字が区別されないからだ。

##  5. <a name='はじめての-node.js'></a>はじめての node.js

さて、その中にプロジェクトとなるフォルダを作ろう。「first_programing」とでもしておこう。
フォルダを右クリックすると「Codeで開く」というメニューが追加されている事に気付く筈だ。それクリックすると Visual Studio Code が立ち上がる。

ここで `Ctrl + Shift + @` を押すと下部にターミナルの画面が出てくる。なにもしていなければ PowerShell が開くと思うのだが、まぁこれで問題無い。

さて、このでてきたターミナルに以下のコマンドを打ちこもう。

```bash
> npn init
```

これはディレクトリ内にパッケージ用の設定ファイルを作るためのコマンドである。コマンドをうちこむといくつか質問をされるからそれに従って打ち込んでいこう。

```bash
This utility will walk you through creating a package.json file.
It only covers the most common items, and tries to guess sensible defaults.

See `npm help init` for definitive documentation on these fields
and exactly what they do.

Use `npm install <pkg>` afterwards to install a package and
save it as a dependency in the package.json file.

Press ^C at any time to quit.
package name: (first_program)
version: (1.0.0)
description: 
entry point: (index.js)
test command:
git repository:
keywords:
author:
license: (ISC)
About to write to C:\home\minori\first_program\package.json:

{
  "name": "first_program",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC"
}


Is this OK? (yes)
```

* package name
  * 作ろうとしているプロジェクトの名前である。デフォルトでディレクリの名前がつくのでそのままエンターを押せばいい
* version
  * 一番最初のバージョン番号をどうするかである。正式版では `1.0.0` にして、開発版では `0.1.0` とかにするのが習慣である。
* description
  * このパッケージの概要を書く。パッケージを公開する時とかに見られるものである。
* entry point
  * このパッケージを実行した時に一番最初に実行されるファイルを指定する。大体 `index.js` か `app.js` という名前にする。
* test command
  * テスト用のコマンドである。決まっているなら入れた方がいいが後で設定する。
* git repository
  * コード管理をするためのリポジトリを指定する。Gitについては後程解説する。
* keywords
  * パッケージに関するキーワードを並べる。公開するときには入れた方がいい。
* author
  * 作者の名前を入れる。パッケージを公開する時には入れた方がいい。
* license
  * パッケージを公開した時にどのような使いかたを許可するかのフォーマットを指定できる。これも公開するような物を作った時に気にすればよい

これらの質問に答えると、「 `package.json` ってファイルを作ったよ」と言われる。Visual Studio Code左側のペインを見ると該当ファイルが生成されているのがわかる。

###  5.1. <a name='入れておいた方がいい拡張機能'></a>入れておいた方がいい拡張機能

左ペインに色々とアイコンが表示されているのがわかると思う。四角いのが4つ、右上がとびでているアイコンをクリックすると拡張機能が大量に表示される。
入れておいた方がいい拡張機能を以下に示す。

* indent-rainbow
* Bracket Pair Colorizer 2
* ESLint
* Prettier
* Material Icon Theme

他にも色々な拡張機能があるので状況に応じて入れると便利である。

<https://qiita.com/ucan-lab/items/e85931bf8276da43cc97>

##  6. <a name='はじめてのプログラム'></a>はじめてのプログラム

さて、ここから実際にプログラムを書き始める。 Visual Studio Code の左ペインを右クリックして「New File」をクリックするとファイル名の入力を求められる。
エントリーポイントと揃えて「index.js」としておこう。

###  6.1. <a name='hello-world'></a>Hello World

エディタでファイルが開かれるはずなので、次のプログラムを入力してみる。
何回か出てきている「コンソールに文字列を表示する」プログラムだ。最初はこうと決っているものなのだ。

```JavaScript
console.log('Hello world!')
```

そしたら下ペインのコンソールで以下のコマンドを打ちこむ。これはnodeに指定したファイルのプログラムを実行させるためのコマンドだ。

```bash
> node index.js
```

無事「Hello world!」と表示されたら成功だ。おめでとう。あなたは無事に最初のプログラムを実行できたのだ！

さて、ほかにもいくつかプログラムを書いてみる。

```JavaScript
console.log('Hello world!')
console.log('こんにちは世界')
console.log('ほげほげほげ')
console.log('ふがふがふが')
```

セーブして実行してみると以下のように表示されるはずだ。

```bash
> node .\index.js
Hello world!
こんにちは世界
ほげほげほげ
ふがふがふが
```

このように、「プログラムは上から順番に実行される」。これは基本原則なので忘れてはいけない。

###  6.2. <a name='変数の使いかた'></a>変数の使いかた

このように文字列を直接打ち込んでもいいが、既に書いたように「変数」というものが存在する。

```JavaScript
const str = 'Hello world!'
console.log(str) // Hello world! と表示される

let num = 1
console.log(num) // 1 と表示される

num = num + 1
console.log(num) // 2 と表示される
```

`const` と `let` というキーワードが出てきたので紹介する。

`let` は変数一般を定義するためのワードである。省略もできるのだが、初めて宣言した変数なのか既に定義されている変数なのかを区別するためにつけておいた方がいい。
ちなみにJavaScriptにはこれを省略させない「厳格モード」というのが存在する。慣れておいた方がいいかもしれない。

`const` は「定数」を定義するために必要なワードだ。このワードで宣言された変数は書き換える事ができない。正確には「参照を書き換える事ができない」。なので直接何かを再代入しようとするとエラーになる

```JavaScript
const str = 'Hello world!'
str = 'Good night!' // エラーになる
```

ここで注意してほしいのは「参照を書き換える事ができない」という点である。「参照」というのは「変数が指している値の大本」である。なので以下のような変更は可能である事に注意すること。

```JavaScript
const obj = {
  value: 10,
  str: 'Hello world!'
}

obj.str = 'Good night!' // これはエラーにならない

obj = {} // これは obj が指す物そのものを変えようとしているのでエラー
```

これは `obj` が指しているオブジェクトそのものは変化しておらず内容のみが変わっているからである。

##  7. <a name='制御構文'></a>制御構文

さて、上から実行するだけじゃ複雑なプログラムなんて書けっこない。
そのためプログラムには「制御構文」というのが存在する。基本的には以下の3つである。

* 関数
* 条件分岐
* くりかえし構文

あとは一応「コメント」というものも制御構文の一つである。

```JavaScript

//  スラッシュ二つの後に書かれた物は行末まで無視される

/*
このように書かれたものに挟まれたものは
全て無視される
*/

```

プログラムの説明を書く時とかに多用される。積極的に使うべきである。

###  7.1. <a name='関数'></a>関数

前にも触れたので軽い説明に留めておく。プログラムを書いておけば後からその部分だけ呼び出せるというものだ。

```JavaScript
const sayHello = function () {
  console.log('Hello!')
}

sayHello()
sayHello()
sayHello()
sayHello()
```

もちろんカッコの中に引数を含める事もできる。

また、関数の定義はこういう書き方もできる。

```JavaScript
const sayAny = (str) => {
  console.log(str)
}

sayAny('hello!')
sayAny('bye!')
```

今は変数に代入しているのであまりありがたみは無いが `(引数, ...) => { 実行したいプログラム }` と書く事で何も無いところに関数を定義できる。引数がいらなければ引数は書かなくてもいい。この書きかたを「ラムダ式」と言う。これは使い捨ての関数を直接他の関数に渡す時によく用いられる。すぐに出てくるので安心されたい。

###  7.2. <a name='条件分岐'></a>条件分岐

条件によって後続のブロックを実行するかどうかを選択する構文である。

```JavaScript
if( /* 真偽値*/ ){
  /* 真の場合に実行されるプログラム */
} else {
  /* 偽の場合に実行されるプログラム */
}
```

`else` 以下は省略して、条件式が真の時だけ実行する文を書くだけでも構わない。

基本的には「比較演算子」というのを使用して「条件式」の結果が `true` か `false` になるような式をカッコの中に書く事になる。以下によく使う物を列挙する。

> 実はJSの「条件」というのはかなり「ガバガバ」なので真偽値以外のものでも認識するのだが、結構[ややこしい話](https://qiita.com/ichi_zamurai/items/ca9b8e92778589c543e3)になってくるので時間があったり必要になった時に調べてみるといい。

* `a === b`
  * `ab`両者が「等しい」時に `true` を返す。数値や文字列等に利用できるが、オブジェクトや配列を丸ごと比較する事はできないので注意する事。
* `a <= b` 、 `a < b`
  * それぞれ`a` が `b` 以下、あるいは `a` が `b` 未満の時に `true` を返す。数値はもちろんだが、文字列であれば辞書式比較をしてくれる。文字列の比較をする場合は文字コード比較なので日本語がまざるとちょっとややこしくなる。
* `a >= b` 、 `a > b`
  * それぞれ`a` が `b` 以上、あるいは `a` が `b` を越えた時に `true` を返す。これも文字列比較ができる。
* `a && b` 、 `a || b`
  * 前者は `a` と `b` が共に `true` の場合に `true` を返す。後者はどちらかが `true` の場合に `true` を返す複数の条件式を組み合わせる時に使用する
    * というのは実は大嘘である。 `a && b` は「`a` が 『[falsy](https://developer.mozilla.org/ja/docs/Glossary/Falsy)』 の場合に `a` を返し、そうでなければ `b` を返す」演算子であり、 `a || b` は 「`a` が 『[truthy](https://developer.mozilla.org/ja/docs/Glossary/Truthy)』 の場合に `a` を返し、そうでなければ `b` を返す」演算子である。 truthy、falsyとは「真とみなせる値」「偽とみなせる値」である。`if` のカッコの中もこのtruthy、falsyという基準で真偽判定が行われている。これが「JavaScriptの条件は 『ガバガバだ』 」と言った所以である。こういう仕様を使ったテクニックもある。

さて、実際の使いかたを見てみる。次のコードを `index.js` に打ちこんで実行してみる。

```JavaScript
let a = 10

if(a < 5){
  console.log('a は5未満です')
} else {
  console.log('a は5以上です')
}
```

無事 `a は5以上です` と表示されただろうか。 `a` に代入される値を色々変えて試してみるといい。

また、カッコの中に直接 `true` や `false` を入れる事もできる。(本当はどんな値でも入れる事ができるが……)どこか別の場所で求めた条件を使い回したり、フラグとして使用している変数をチェックしたりする時にそんな書きかたをする。

```JavaScript
let flag = true

if(flag){
  console.log('フラグが立っています')
}
```

###  7.3. <a name='くりかえし構文(`while`)'></a>くりかえし構文(`while`)

`while` 構文は条件式が真の間処理をループさせる機能である。以下はフィボナッチ数列を第20項まで求めるプログラムである。

> フィボナッチ数列というのはよく数学で出てくる数列で、 $\lbrace T_1 = 1, T_2 = 1, T_{n+2} = T_{n+1} + T_{n} \rbrace $ で定義される数列である。

```JavaScript
let fibbonach = [1, 1]

while(fibbonach.length < 20){
  fibbonach.push(
    fibbonach.at(-1) + fibbonach.at(-2)
  )
}

console.log(fibbonach)
/*
[
    1,    1,    2,    3,    5,
    8,   13,   21,   34,   55,
   89,  144,  233,  377,  610,
  987, 1597, 2584, 4181, 6765
]
と表示される
*/
```

新しい関数が出てきたので紹介する。 `.push()` はその配列の末尾に渡した要素を追加してくれる関数だ。

```JavaScript
arr = [1, 2]
arr.push(3)
console.log(arr) // [1, 2, 3] と表示される
```

また、 `.at()` は配列の要素を参照する関数で、基本的には `[]` と同じ動きをする。だがこれには負の数も指定でき、その場合は末尾から数えた要素が参照できる。

```JavaScript
let arr = [1, 2, 3]
console.log(arr[0]) // 1
console.log(arr.at(1)) // 2
console.log(arr.at(-1)) // 3
```

さて、それではもういちどプログラムを見てみる。

```JavaScript
let fibbonach = [1, 1]

while(fibbonach.length < 20){
  fibbonach.push(
    fibbonach.at(-1) + fibbonach.at(-2)
  )
}

console.log(fibbonach)
```

* `fibbonach` が定義されている。要素の数は2つである。
* `while` ループに入る。最初に条件式が判定される。`fibbonach.length` は`2` なので中の処理は実行される。
  * `fibbonach` の末尾に値が追加される。内容は `fibbonach` の末尾2つを足した物である。結果 `fibbonach` の要素が増える。
* 処理がおわったので条件式が判定される。`fibbonach.length` は`3` なので中の処理は実行される。
* ………
* 処理がおわって条件式が判定されるタイミングで `fibbonach.length` が `20` (以上)であった場合にループを抜け、後続の処理が実行される。
* `fibbonach` が出力される。

このように、一定の条件を指定しその間ずっと処理をくりかえすのが `while` ループである。なお、ループ開始時に条件式が真でないとこのループは一度も実行されないが、「少なくとも一度は実行したい」という時のために `do-while` 構文というのが用意されている

```JavaScript
do {
  // 実行したい文
} while( /**条件式**/ )
```

たまに使いたくなる時がある。

###  7.4. <a name='くりかえし構文(`for`)'></a>くりかえし構文(`for`)

```JavaScript
let strs = ['りんご', 'ばなな', 'みかん']

for(let index = 0; index < strs.length; index++){
  console.log(index + ':' + strs[index])
}

console.log('ループ終了')

/*
0:りんご
1:ばなな
2:みかん
ループ終了
と表示される
*/
```

実は `+` の演算子は文字列の結合をしてくれたり、その時は数値が文字列に勝手に変換されたりと色々あるのだが、とりあえずこの `for` というやつについて解説する。

```JavaScript
for( /* 初期化処理 */; /*ループ条件*/; /*ループ終了時の処理*/){
  /* 実行させたいプログラム */
}
```

* 初期化処理
  * `for` 文に入る時に一度だけ実行される文である。普通はカウンタ変数というものを用意してそれを初期化する。必要がなければ省略する事ができる。
* ループ条件
  * `for` 文を実行するかどうかの条件をここに入れる。この式が falsy になればループを抜け次の処理に移る。省略すると常に `true` という扱いになる。
* ループ終了時の処理
  * `for` 文内の文が実行される毎に実行される処理である。普通はカウンタをインクリメントしたりする処理を入れる。 `++` は対象の変数を1増やす演算子である。必要がなければ省略する事ができる。

これをふまえてもう一度先のプログラムを見てみる。

```JavaScript
let strs = ['りんご', 'ばなな', 'みかん']

for(let index = 0; index < strs.length; index++){
  console.log(index + ':' + strs[index])
}

console.log('ループ終了')
```

* 最初に `strs` という変数が定義されている。いくつかの文字列が入っている。
* `for` ループに入り、まず `index` という変数が定義される。初期値は `0` である。
* 次にループ条件が確認される。 `.length` はその配列の長さを示すメンバである。今 `0 < 3` は `true` なのでこのループは実行される。
* ループの中身が実行される。
  * `index` は `0` であるため、 `strs[0]` である `りんご` がとりだされ `0:りんご` という文字列が出力される。
* ループ終了時の処理が実行される。`index` の値が1増える。
* ループ条件が確認される。 `index` の値は `1` であるため、`1 < 3` は `true` であるためこのループは実行される。
* ループの中身が実行される。
* ………
* `index` の値が3になった時、 `3 < 3` が `false` になるためこのループは実行されず、以降の処理に進む。
* `console.log('ループ終了')` が実行される

という流れになる。基本的なループであるし、こういう単純な使いかた以外にも応用はあるのだが素朴であるが故にこの `for` ループというのは扱い辛い。
インデックス変数に気を配らなければいけないし、例えばこの使いかただと「配列のインデックス」と「インデックス変数」というのが独立してしまい意味が不明瞭になる。

###  7.5. <a name='くりかえし(`foreach()`)'></a>くりかえし(`forEach()`)

例えば先のように「配列の中身を全て出力したい」というのであれば以下のような方法がある。

```JavaScript
let strs = ['りんご', 'ばなな', 'みかん']

const printIndexAndStr = function (food, index){
  console.log(index + ':' + food)
}

strs.forEach(printIndexAndStr)

/*
0:りんご
1:ばなな
2:みかん
と表示される
*/
```

配列に存在する `.forEach()` という関数は渡された関数を配列の中身毎に実行してくれる。

渡される引数は二つある。配列の中身そのものとそのインデックス番号だ。つまり上のプログラムの動きは次のようになる。

* `strs` が定義される。
* `printIndexAndStr` が定義される。これは関数である。
* `strs.forEach()` に `printIndexAndStr` を渡して実行する
  * 配列の中身それぞれに対して `printIndexAndStr(中身, インデックス番号)` が実行される

どうだろう。先程の説明に比べて大分スッキリとした解釈になったのではないか。

あるいは、この `printIndexAndStr` という関数はここでしか使わないというのであればわざわざ変数に格納するまでもない。

```Javascript
let strs = ['りんご', 'ばなな', 'みかん']

strs.forEach(
  (str, index) => {
    console.log(index + ':' + str)
  }
)
/*
0:りんご
1:ばなな
2:みかん
と表示される
*/
```

思い出してほしい。 `(引数, ...) => { 実行したいプログラム }` という記述はラムダ関数の記述だ。 `forEach()` に渡すべき関数をこの中で直接定義している。

###  7.6. <a name='くりかえし(`map()`)'></a>くりかえし(`map()`)

もうひとつ便利なものを紹介する。それが `.map()` である。これは渡された関数に従い配列から新しい配列を生成する。

```JavaScript
let nums = [1, 2, 3, 4, 5]

let doubles = nums.map(
  (x) => {
    return x*2
  }
)

console.log(doubles)
// [ 2, 4, 6, 8, 10 ] と表示される
```

`doubles` には `nums` の配列の中身が全て倍になった新しい配列が生成され格納される。さて、もう一つ例を見てみよう。

```javascript
let points = [10, 40, 53, 23, 12]

let passeds = points.map(
  (x) => {
    if(x < 30){
      return '赤点'
    } else {
      return '合格'
    }
  }
)

console.log(passeds) // [ '赤点', '合格', '合格', '赤点', '赤点' ] と表示される
```

配列に入っている数字が30点未満なら「赤点」、30点以上なら「合格」という文字列に変換する関数を渡している。

さてこの関数、というかこの処理、どこかで見た事無いだろうか。そうである。「写像」の項で出てきた「テストの点数が30点未満なら〜」のやつである。
この関数はその名の通り「写像(map)」を行う事のできる関数なのである。もちろんこいつはプログラムなので、途中に色々な処理(画面出力とか)も挟む事ができるのだが、このように配列にある多数の要素を一度に「写す」事ができる。

###  7.7. <a name='くりかえし(`reduce()`)'></a>くりかえし(`reduce()`)

map と合わせて重要な処理が存在する。「畳みこみ」と呼ばれる処理である。例えば配列の中身を全て足し合わせる処理を以下のように書ける。

```JavaScript
const array1 = [1, 2, 3, 4]
const add = (previousValue, currentValue) => previousValue + currentValue

let sum = array1.reduce(add, 0)
console.log(sum); // 10 と表示される
```

`arr.reduce(f, 初期値)` とする事で `arr` の内容が関数 `f` に従って先頭から値が計算される。具体的には以下のような計算が行われる。

* `arr` の先頭の値( `a0` とする) と初期値 ( `b` とする) を元に `b0 = f(b, a0)` が計算される
* `arr` に次の値( `a1` とする) があれば先の `b0` を元に `b1 = f(b0, a1)` が計算される
* `arr` に次の値( `a2` とする) があれば先の `b1` を元に `b2 = f(b1, a2)` が計算される
* 配列の末尾まで以上をくりかえし、最後の計算結果 `bn` を返却する

言葉で説明すると回りくどいが、配列の中身を先頭からポコポコ初期値にくっつけていくイメージをしてもらえればいいだろうか。

こうすれば「畳みこみ」がどう動いているかよく観察する事ができる。

```JavaScript
const array1 = [1, 2, 3, 4];
const add = (previousValue, currentValue) => {
  console.log('[reducer]')

  console.log(`previousValue : ${previousValue}`)
  console.log(`currentValue : ${currentValue}`)
  
  let added = previousValue + currentValue
  console.log(`added : ${added}`)
  
  return added
}
let sum = array1.reduce(add, 0)
console.log(sum);

/*
[reducer]
previousValue : 0
currentValue : 1
added : 1
[reducer]
previousValue : 1
currentValue : 2
added : 3
[reducer]
previousValue : 3
currentValue : 3
added : 6
[reducer]
previousValue : 6
currentValue : 4
added : 10
10
*/
```

ちなみに、バッククォートで囲んだ文字列は `${}` とする事で変数や式を直接埋め込む事ができる。便利なので覚えておこう。

###  7.8. <a name='くりかえし(`for...in`)'></a>くりかえし(`for...in`)

さて、配列のくりかえしが存在するならオブジェクトに対するくりかえしも存在する。それが `for...in` 構文である。

```JavaScript
let obj = {
  a: 10,
  b: 34,
  c: 25
}

for(const name in obj){
  console.log(name, obj[name])
}
/*
a 10
b 34
c 25
*/
```

`in` の直前に宣言した変数にオブジェクトのメンバ名が入り、オブジェクトに入っているメンバ分だけループをしてくれる。
なお通常オブジェクトメンバへの参照は `obj.a` のようにドット演算子で行うが、変数内の文字列等で参照する場合は `obj[name]` のようにブラケットを用いる。

オブジェクトの名前が取得できるので、例えばこういう事もできる。

```JavaScript
const sample = [10, 54, 23, 75, 84, 25, 64, 32, 13, 64]

const statisticsFunction = {
  average (arr) {
    let sum = arr.reduce( (p, c) => p+c , 0)
    return sum/arr.length
  },
  max (arr) {
    return Math.max(...arr)
  },
  variance (arr) {
    let avr = this.average(arr)
    let sn = arr.reduce( (p, c) => p + (c-avr)**2 , 0)
    return sn/arr.length
  }
}

let sampleStatics = {}

for(const calc in statisticsFunction) {
  sampleStatics[calc] = statisticsFunction[calc](sample)
}

console.log(sampleStatics)
// { average: 44.4, max: 84, variance: 652.24 }
```

`statisticsFunction` なるオブジェクトには渡した配列の統計情報を計算する関数がいくつか入っている。
それを `for...in` で順次実行していくのだが、関数名をそのまま結果をまとめるオブジェクトのメンバ名として利用している。

##  8. <a name='じゃんけんゲーム--設計、実装、テスト、コード管理-'></a>じゃんけんゲーム -設計、実装、テスト、コード管理-

ここから実際にプログラムを書きながら設計、実装、テスト、コード管理についての基本的な流れについて説明していく。

###  8.1. <a name='パッケージ用のディレクトリ作成とコード管理'></a>パッケージ用のディレクトリ作成とコード管理

せっかくなのであたらしいディレクトリを作ろう。名前は「 `janken` 」とかでいいだろう。
そうしたらそのディレクトリを右クリックして「Codeで開く」を選択、 `Ctrl + Shift + @`  でターミナルを開き、 `npm init` を実行する。
前回のように色々聴かれるので、適当に入力しよう。

```bash
> npm init
This utility will walk you through creating a package.json file.
It only covers the most common items, and tries to guess sensible defaults.

See `npm help init` for definitive documentation on these fields
and exactly what they do.

Use `npm install <pkg>` afterwards to install a package and
save it as a dependency in the package.json file.

Press ^C at any time to quit.
package name: (janken)
version: (1.0.0) 0.1.0
description: this is rock-paper-scissors
entry point: (index.js)
test command:
git repository:
keywords: game
author:
license: (ISC)
About to write to C:\home\minori\janken\package.json:

{
  "name": "janken",
  "version": "0.1.0",
  "description": "this is rock-paper-scissors",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "game"
  ],
  "author": "",
  "license": "ISC"
}


Is this OK? (yes)
```

さて、ここから git を使用して「コード管理」というのを行っていく。gitというのはソースコードの履歴の管理を行ってくれるもので、こまめに登録さえしていればいつでも以前登録した状態に戻せたり、branchという機能を使ってそれぞれの機能の開発を個別に行ってからまた合流させたりなんかできるのだが、gitについて詳しく解説しているとそれだけで分厚い本ができるのでとりあえず履歴の管理ができればいいものとし扱う。

// git の初期設定の話を書く

さて、ターミナルに戻って `git init` と打ちこもう。

```bash
PS C:\home\minori\janken> git init
Initialized empty Git repository in C:/home/minori/janken/.git/
```

これでこのディレクトリはgitの管理下に置かれるようになった。
左ペインの枝みたいなアイコン(以降「gitアイコン」と呼ぶ)に数字がでてきた事だろう。これをクリックすると「ソース管理タブ」というのが開ける。「changes」というタブの下に `package.json` が表示されている筈だ。
カーソルを合わせるとさらにアイコンが表示されるので、その中の「+」のアイコンをクリックしよう。

そうすると「Staged Changes」というタブに今クリックした `package.json` が移動する。この状態で上のテキストボックスに適当なコメント(英語が望ましいが、「package.jsonの生成」とかでいいだろう)を入れてそのまま `Ctrl + Enter` を押す。こうしてgitへの「ファイルの登録」が完了した。

gitではこのように以下の流れでファイルを管理する。

* ファイルを編集する
* 記録したいファイルを選択する(これを stage に上げるという)
* コメントと共に記録する(これを commit という)

わざわざファイルを先に選択するのは、機能の修正や追加など細かい単位でコミットができるようにするためだ。複数人で開発をする時とかはコミットの単位を厳密に意識しないと殺される。いや、マジで。

ともあれ最初のファイルがこれで記録された、試しに `package.json` に適当な文章を打ち込んでセーブしてみよう。そうするとまたgitアイコンに数字が表示され、クリックすると `package.json` が表示されている筈だ。

今度は矢印のアイコンに注目する。ホバーすると「Discard Changes」(変更を破棄する)と表示される通り、このファイルに行った変更を切り戻す事ができる。クリックすると警告が表示され、「Discard Changes」を選択するとファイルの状態が戻る筈だ。

何か機能を追加したりソースに変更を加えたら小まめにコミットする事。これを怠ると大量にコードを書いていざ動かそうとするとうまくいかず、どこが原因かわからないままその大量のコードを切り戻すなんて事が起りかねない。

###  8.2. <a name='外部パッケージのインストールと「管理しないコード」'></a>外部パッケージのインストールと「管理しないコード」

さて、もうすこし準備がある。プロンプト上での対話入力を可能にする `inquirer` とテストを実行するために必要な `jest` というパッケージをインストールする。
パッケージのインストールは `npm` で行う。以下のコマンドをプロンプトにそれぞれうちこむ事

```bash
> npm i inquirer
```

```bash
> npm install --save-dev jest 
```

`--save-dev` オプションは開発用にライブラリを入れ、実際の実行の時には必要無い事を明示するオプションだ。
実行には少し時間がかかる。実行が終わると `node_modules` というディレクトリが生成されそこに各種ライブラリがインストールされる。

プロジェクトフォルダの中に大量にファイルが増えたので、gitアイコンの数字が大変な事になっている、がこれらのファイルはコミットしてはいけない。
ライブラリは外部の物であるし、その情報は `package.json` に記録されているので `npm install` と打てばそれらはすぐにインストールできる。
なので今インストールしたファイル群はソースコード管理の対象から除かなくてはいけない。

そこでファイル一覧(右ペインの一番上のアイコンから表示できる)から `.gitignore` というファイルを追加しよう。これはgit管理しないファイルやフォルダを指定しgitに認識させなくすることのできるファイルだ。
とりあえず以下のように書いてみよう。

```
node_modules/
```

これでソース管理タブの中身がすっきりした筈だ。
このようにプログラムには「管理するべきファイル」とそうでないファイルが存在する。 `node_modules` 以外にも沢山存在するので <https://www.gitignore.io/> で生成してしまおう。
ページに飛んでテキストボックスに node と入力してから「作成する」ボタンを押すと適切に生成された `.gitignore` ファイルの中身が表示される。このままコピペしよう。

ファイルに変更をしたのでコミットを忘れずに。まずは `.gitignore` だけを「.gitignore の追加」とでもしてコミットするのがおすすめだ。次にライブラリのインストールによって `package.json` と `package-lock.json` が変更追加されているので、「ライブラリの追加」としてこれらをコミットしよう。

###  8.3. <a name='設計と実装'></a>設計と実装

タイトルにある通り、コンピュータとじゃんけんをするようなゲームを考えよう。
多くのプログラミング指南本だとここで「まず [フローチャート](https://www.google.com/search?q=%E3%83%95%E3%83%AD%E3%83%BC%E3%83%81%E3%83%A3%E3%83%BC%E3%83%88&sxsrf=AOaemvKr9Gc5ojFGxbDsnrwLBK3lSZpV2A:1642606858087&source=lnms&tbm=isch&sa=X&ved=2ahUKEwitkaCyk771AhXns1YBHQbRCB0Q_AUoAXoECAoQAw&biw=1476&bih=865&dpr=1) を書きましょう」と言われるのだが、 **それは罠だ** 。
フローチャートというのはプログラムのアルゴリズムを考える時によく使われる「流れ図」なのだが先に書いた通りプログラムは「上から実行される」「分岐、くりかえし、サブルーチンの制御構文がある」のという原則で動いている。

> 昔の言語には `GOTO` というプログラム内のどこにでも飛べる構文があったがそれを使ってしまうとプログラムが著しく読みづらくなってしまうため現在では禁忌とされている。

フローチャートは「図」であるため、上下左右どこにでも処理を書く事ができる。素人がこれを書くと地図みたいな図ができあがりプログラムに落すのがあまりにも困難なものになる。
なので以下のようにテキストで箇条書きにするのがのぞましい。

* 起動するとゲームがはじまる
* じゃんけんをする
  * プレイヤーの手の入力を促す
  * コンピュータの手をランダムに決める
  * 入力された手とコンピュータの手を比較して勝敗を求める
  * 結果を出力する
  * もういちどやるか尋ね入力を促す
  * もういちどやるのであれば再度じゃんけんが始まる。
* プログラムを終了する

考えなければいけない事がいくつもある。

* 入力をさせるにはどうすればいいか
* じゃんけんの勝敗の判定はどうすればいいか
* プログラムをループさせて、好きなタイミングでやめるにはどうしたらいいか

等々。とりあえずは作りかたをイチから指南するのでその通りに作ってみるといい。

####  8.3.1. <a name='概要設計'></a>概要設計

さて、これから具体的なプログラムを書いていくのだが、プログラムを書くにあたって、最初にどんな処理をするかをメモしておくといい。ここの分解の単位をどうするかがプログラムの腕の見せ所の一つでもある。 `index.js` を用意したらとりあえずこんな感じに書いてみよう。

```JavaScript
//  くりかえし
  // プレイヤーの手をうけとる
  // コンピュータの手を決める
  //  勝敗を求める
  //  勝敗を出す
  // 再戦するかを聞く
// くりかえしおわり
```

####  8.3.2. <a name='入力のうけとりかた'></a>入力のうけとりかた

まず何を持ってしてもユーザーの入力を受けとれるようにしなければいけない。実は JavaScript は元々ブラウザで動かす言語であったため「入力」という概念が標準で存在しない。
であるが `npm init` で使われているようにコンソールで動く以上その仕組みは存在する。今回は [inquirer](https://www.npmjs.com/package/inquirer) というライブラリを使おう。

JavaScript で使用されるライブラリは「パッケージ」と呼ばれ、それらはすべてリンク先の「npm」というサイトで管理されている。使用方法もここに書いてあるのだが、大体は英語である。ある程度英語が読めなければいけない。
まぁ今時翻訳ソフトも充実しているので言う程困る事はない。

さて、とりあえず「Installation」の項を見てみよう。インストールは先にやっているので使用例を見る。

> ```JavaScript
> var inquirer = require('inquirer');
> inquirer
>   .prompt([
>     /* Pass your questions in here */ // 訳 : ここに質問を渡す
>   ])
>   .then((answers) => {
>     // Use user feedback for... whatever!! 訳 : ユーザーの入力を利用して……何でも(書ける)！
>   })
>   .catch((error) => {
>     if (error.isTtyError) {
>       // Prompt couldn't be rendered in the current environment  訳 : プロンプトが描画できなかった時のエラー
>     } else {
>       // Something else went wrong  訳 : その他の間違い
>     }
>   });
> ```

正直これだけじゃサッパリである。少し下にいくと「[Methods](https://www.npmjs.com/package/inquirer#methods)」という項目があるので見てみよう。ちなみに「method」というのはオブジェクトの中のメンバ関数を得にこう呼ぶ。

> Methods
>
> inquirer.prompt(questions, answers) -> promise
>
> Launch the prompt interface (inquiry session)
>
> questions (Array) containing *Question Object* (using the *reactive interface*, you can also pass a Rx.Observable instance)
> answers (object) contains values of already answered questions. Inquirer will avoid asking answers already provided here. Defaults {}.
> returns a Promise

とりあえずこいつの使いかたを覚えておけばよさそうだ。第1引数に「[Question Object](https://www.npmjs.com/package/inquirer#question)」なるものの配列を渡し、第2引数にはデフォルトで利用したい回答を格納してもよい。そして「 `promise` 」なる物が帰ってくるらしい。[使用例](https://github.com/SBoudrias/Inquirer.js/blob/master/packages/inquirer/examples/pizza.js) を見ればなんとなく使いかたがわかる。 `promise` が帰ってきたらその後に `.then(callbackFunction)` という形でメソッドを呼び、その中に実行したい処理を入れればいい。

`promise` を返す関数 `retuenPromise()` があった場合の基本的な使いかたはこうだ。 `then` の中の `value` には `promise` が生成した何かしらの値が渡ってくる。

```JavaScript
returnPromise(/* 引数があれば渡す */).then((value) => { /*後続処理*/ })
```

> このように、関数を実行した結果がまたメソッドを持った物である場合にそのメソッドを連ねて書く事を「メソッドチェーン」と呼んだりもする。

なぜこんな書き方をするのかというと、 `promise` というのは基本的に時間のかかる処理を非同期に行うためのしくみだからだ。関数が実行されてもその結果を待たず、実行が完了したら `.then()` 以下の処理を実行するようになっている。

あるいは、 `promise` についてはもう一つ使いかたがある。 `await` というキーワードを使い以下のように書くと `promise` の処理結果を直接変数に入れる事ができる。

```JavaScript
value = await returnPromise()
```

ただし、この書き方はそれ自体が「非同期関数の中」、つまり `promise` を返すような関数でしか使用できないので注意。なので、最初のプログラムにしては不相応なやりかたでこれを使用する。 `index.js` に書いていたメモを以下の文言で囲む事。

```JavaScript
;(async () => {
  //  くりかえし
    // プレイヤーの手をうけとる
    // コンピュータの手を決める
    //  勝敗を求める
    //  勝敗を出す
    // 再戦するかを聞く
  // くりかえしおわり
})()
```

`async` というキーワードはその関数が非同期関数である事を示している。
非同期の関数を一つ作成して、最後に `()` をつけてその関数を即座に実行している。
昔は別の用途でよく使われていた手法であるのだが、今回は無理矢理非同期の関数をトップレベルで実行するのに使用する。この中にメインの処理を書いてしまおう。

####  8.3.3. <a name='プログラムを書いていく'></a>プログラムを書いていく

さて、これから少しずつプログラムを書いていく。
まずくりかえしと書いてあるのでくりかえす文を書こう。何が適当だろうか。回数が決ってる訳ではないので `while` 文が適当だろうか。とりあえず書いておくが無限ループになってしまうと困るのでフラグでも立てておこう。きっと再戦するか聞いた時にフラグを `false` にするから

> 「フラグ」という言葉にピンと来なくても、「死亡フラグ」という言葉は聞いた事があるだろう。「フラグ」とは「ある条件が満されたか」という値を保持しておく変数である。

```JavaScript
;(async () => {
  //  くりかえし
  let flag = true
  while(flag){
    // プレイヤーの手をうけとる
    // コンピュータの手を決める
    // 勝敗を求める
    // 勝敗を出す
    // 再戦するかを聞く
    flag = false
  }
  // くりかえしおわり
})()
```

プレイヤーの手をうけとれるようにしなければいけない。先に出てきた `inquirer` を使おう。
具体的な入力は後から考えるとして、とりあえず質問がでてくるしくみだけ書いておこう。何が入力されたのか見るためにログをとりあえず入れておこう。これは後で消す。

```JavaScript
const inquirer = require('inquirer')

;(async () => {
  //  くりかえし
  let flag = true
  while(flag){
    // プレイヤーの手をうけとる
    let answer = await inquirer.prompt([
      {
        type: 'input',
        name: 'hand',
        message: '質問が入る',
      }
    ])
    console.log(answer)
    // コンピュータの手を決める
    // 勝敗を求める
    // 勝敗を出す
    // 再戦するかを聞く
    flag = false
  }
  // くりかえしおわり
})()
```

……うーん。 `prompt` に渡すオブジェクトが直接書いてあるのは見通しが悪い。どうせ定数なのだから外に出してしまおう。

```JavaScript
const inquirer = require('inquirer')

const question = {
  type: 'input',
  name: 'hand',
  message: '質問が入る',
}

;(async () => {
  //  くりかえし
  let flag = true
  while(flag){
    // プレイヤーの手をうけとる
    let answer = await inquirer.prompt([
      question
    ])
    console.log(answer)
    // コンピュータの手を決める
    // 勝敗を求める
    // 勝敗を出す
    // 再戦するかを聞く
    flag = false
  }
  // くりかえしおわり
})()
```

ここまで作ったら一度動かしてみるといい。
ちゃんとプロンプトから入力をうけとれてるだろうか。

```bash
> node index.js
? 質問が入る hogehoge
{ hand: 'hogehoge' } 
```

入力は自由入力じゃなくてちゃんと選択肢を与えた方がいいかもしれない。
ただ「グー」とかそういう文字列が帰ってきても処理に困るから、リスト選ばせて数字でも返してくれるような使いかたは無いだろうか。

思い出してほしい。「 **ほしいと思ったものは、大体誰かが作ってる。** 」

`linquirer` の [Question](https://www.npmjs.com/package/inquirer#question) の項を見ると、選択肢を記述する `choices` のところにこう書いてある。

> choices: (Array|Function) Choices array or a function returning a choices array. If defined as a function, the first parameter will be the current inquirer session answers.
> Array values can be simple `numbers`, `strings`, or `objects` containing a `name` (to display in list), a `value` (to save in the answers hash), and a short (to display after selection) properties.

なるほど。 `name` と `value` を持つオブジェクトを `choises` に入れておけば表示名と返却値を分ける事ができるらしい。

```Javascript
const inquirer = require('inquirer')

const hands = [
  { name: 'グー', value: 0 },
  { name: 'チョキ', value: 1 },
  { name: 'パー', value: 2 },
]

const question = {
  type: 'list',
  name: 'hand',
  message: 'あなたの手は？',
  choices: hands
}

;(async () => {
  //  くりかえし
  let flag = true
  while(flag){
    // プレイヤーの手をうけとる
    let answer = await inquirer.prompt([
      question
    ])
    console.log(answer)
    // コンピュータの手を決める
    // 勝敗を求める
    // 勝敗を出す
    // 再戦するかを聞く
    flag = false
  }
  // くりかえしおわり
})()
```

これで実行すると以下のようになる。選択肢は選んだら消えてしまうので結果しか残っていないがちゃんとリスト表示されている。

```bash
> node index.js
? あなたの手は？ パー
{ hand: 2 }
```

このように少しずつ見えるところから実装しながら進めていくというのがいいだろう。

####  8.3.4. <a name='テスト'></a>テスト

つぎにコンピュータの手を決めるところを書こう。これは少し書く事が多そうだ。
ランダムで手を決めなければいけない、手は3種類のどれかが絶対に出ないといけない。

このように少しでも考える事が増えたら、 **その処理をそのままそこに書こうとしてはいけない** 。
具体的にはそのための関数を別途作成し、さらにその関数の正当性を確保するための **テスト** を書かなければいけない。

という訳でここで自分でじゃんけんのためのライブラリを作ろう。 `janken.js` というファイルを作成し、そこにコードを書いていく。
まずは適当に「ガワ」を書こう。

```JavaScript
const choiceCpuHand = () => {
  return 1
}

module.exports = {
  choiceCpuHand
}
```

上の関数はこれから「コンピュータの手をランダムに決める」関数になる予定の関数である。ここで重要なのは下の `module.exports` である。
これを書くと `inquirer` を使った時と同様に `import` 文でここに書かれた関数が使用できるようになる。もういちど `index.js` に戻って次の記述を足してみよう。

```JavaScript
const inquirer = require('inquirer')
const janken = require('./janken')   // ← ここと

const hands = [
  { name: 'グー', value: 0 },
  { name: 'チョキ', value: 1 },
  { name: 'パー', value: 2 },
]

const question = {
  type: 'list',
  name: 'hand',
  message: 'あなたの手は？',
  choices: hands
}

;(async () => {
  //  くりかえし
  let flag = true
  while(flag){
    // プレイヤーの手をうけとる
    let answer = await inquirer.prompt([
      question
    ])
    console.log(answer)
    // コンピュータの手を決める
    let cpuHand = janken.choiceCpuHand()  // ← ここと
    console.log(`cpuHand  : ${cpuHand}`)  // ← ここ
    // 勝敗を求める
    // 勝敗を出す
    // 再戦するかを聞く
    flag = false
  }
  // くりかえしおわり
})()
```

実行してみると確かに `cpuHand  : 1` という記述が追加されているのがわかる。これでこの関数がきちんと機能しているのがわかった。
さて、じゃあこれから `choiceCpuHand` の実装をする……訳ではない。この関数のテストをまず作る方がいい。関数のテストとはそのまま関数の仕様になり、また正当性のチェックを用意に可能にする。

……といっても今回はランダムな値を出力するので厳密なテストができない。ちゃんとしたテストの作りかたは勝敗判定の時に語るとして、今回は「テストというしくみがある」事だけ覚えてもらえばいい。

という訳でプロジェクトに `test` というディレクトリを作成し、その中に `janken.test.js` というファイルをまず作ろう。ついでに `package.json` を書き変えよう。 `test` の項に書いてある文言を `jest` に差し替える。

```json
{
  "name": "janken",
  "version": "0.1.0",
  "description": "this is rock-paper-scissors",
  "main": "index.js",
  "scripts": {
    "test": "jest"
  },
  "keywords": [
    "game"
  ],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "inquirer": "^8.2.0"
  },
  "devDependencies": {
    "jest": "^27.4.7"
  }
}

```

ここで一回コンソールで `npm test` と実行してみよう。エラーメッセージが出てくるだろうか。

```bash
> janken@0.1.0 test
> jest

 FAIL  test/janken.test.js
  ● Test suite failed to run

    Your test suite must contain at least one test.
```

恐れる事はない。「実行するべきテストが無い」と言われているだけだ。このようなメッセージが出てこなかったら jest のインストールができていない。
最初の方に書いてしまったから忘れてるかもしれないが次のコマンドでインストールできる。

```bash
npm i --save-dev jest
```

> [jest](https://jestjs.io/ja/) とは JavaScript でのテストを簡単に行えるようにしてくれるフレームワークである。
> `test.js` という文字列が入ったファイルを用意しておけばそれらのテストを全て実行してくれ、エラーがあったら検出してくれる。
> もちろんきちんとしたテストを書くというのはそれだけで大変だ。テストとはその関数の仕様でありプログラムの完成度に大きく影響を及ぼす物である。

さてテストが無いといわてはしょうがない。テストを書こう。 `janken.test.js` に戻ってこのようなコードを書く。

```JavaScript
test('コレはモックです', () => {
  expect(1).toBe(1)
  console.log('ちゃんと実行されていますか？')
})
```

テストの構文を覚えてもらうためになにもしないテストを書いた。

まずテストをするためにはコードの中に `test` という関数を書く。第1引数はそのテストがどのようなテストを行っているかの注釈を書く場所で、内容がわかればなんでもいい。
第2引数に具体的なテストを書く。基本的には「アサーション」というものを書き連ねていく。関数が正当な値を返しているかのチェックだ。 `expect(1).toBe(1)` のところがそうで、
本来はこの `expect` という関数の中にテストしたい関数や結果の変数を入れる。 `.toBe(value)` は実行結果の値が渡された値それそのものであるかをチェックする関数である。
このようにテストとして関数等を実行した結果を検査するものを「アサーション」と呼ぶ。

再び `npm test` とやると以下のような表示が出るはずだ。

```bash
> npm test

> janken@0.1.0 test
> jest

  console.log
    ちゃんと実行されていますか？

      at Object.<anonymous> (test/janken.test.js:3:11)

 PASS  test/janken.test.js
  √ コレはモックです (13 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        0.363 s
Ran all test suites.
```

テストが実行されて、ちゃんと合格している。試しに記述をこう変えてみる。

```JavaScript
test('コレはモックです', () => {
  expect(2).toBe(1)
  console.log('ちゃんと実行されていますか？')
})
```

```bash
> npm test

> janken@0.1.0 test
> jest

 FAIL  test/janken.test.js
  × コレはモックです (2 ms)

  ● コレはモックです

    expect(received).toBe(expected) // Object.is equality

    Expected: 1
    Received: 2

      1 |
      2 | test('コレはモックです', () => {
    > 3 |   expect(2).toBe(1)
        |             ^
      4 |   console.log('ちゃんと実行されていますか？')
      5 | })

      at Object.<anonymous> (test/janken.test.js:3:13)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 total
Snapshots:   0 total
Time:        0.369 s, estimated 1 s
Ran all test suites.
```

2は1ではないので当然これは失敗する。ご丁寧にどこで失敗したかも教えてくれる。 Jest はかなりエラーメッセージが丁寧なので、英語がちゃんと読めればすぐになにが失敗しているかがわかる。

####  8.3.5. <a name='テストファーストという考えかた'></a>テストファーストという考えかた

さて、テストの書きかたがわかったのでテストを書こう。 **関数本体の実装より先に** 、だ。
何度か書いているが、テストとは仕様でありその関数の正当性をチェックするためのものである。テストを書きながらその関数はどんな仕様なのかを考え、テストを実行しながらその正当性を証明し、
テストが書きづらいと思ったらそれは関数の設計が綺麗に分割されてない証である。よって **テストは何よりも優先される** 。

これを「テストファースト」或いは「テスト駆動開発(Test-Driven Development : TDD)」と呼ぶ。  ~~1人で開発してるとそんな余裕も無かったりするのだが。~~

####  8.3.6. <a name='テストを書く'></a>テストを書く

テストを書くというのは仕様を決めるという事だ。だからまず「CPUの手を決める」という関数の仕様を決めよう。

* 実行するとランダムに0から2の整数が出てくる

一言で言うとこれなのだが、これをもっと掘り下げなければいけない。

1. 実行した結果は「0, 1, 2」のどれかれあり、 **それ以外であってはいけない**。 
1. 「0, 1, 2」の **どの手も出る可能性がある必要がある**
1. どの手が出るかはわからない

こんなところだろうか。ちょっと3番のランダム性をテストするのはむずかしい。というよりはランダムな値を出す手法はライブラリにありその性能は担保されているからテストする必要が無い。だから1と2に絞ってテストを行うことにする。ただし今回はすごい適当だ。ランダム性を持つ入出力をテストするのは難易度が高いからだ。

今回は適当に以下のようなテストを実行することにする。

1. 関数を大量に(適当に100回ぐらい)実行する
1. それぞれについて0,1,2のどれかの値が出ているか確認する。それ以外の値が出てきたらテスト失敗とする
1. 0,1,2全ての値が出ているか確認する。出ていない数値があったらテスト失敗とする。

> 本来はここで乱数に「シード値」というのを与え出てくる乱数を固定するという手法をとるのだが、JavaScriptの乱数関数にはシードをセットする機能が無い。他の言語でこのようなテストを行う時はきちんとシードを設定して乱数の固定を行った上でテストする事。

という訳でテストを実装していく。もっと効率のいい方法があるのだが今回は適当にこんな感じに実装する。

```JavaScript
const janken = require('../janken')

test('choiceCpuHand', () => {
  let hands = new Array(100)
  hands.fill(0)
  let isExists0 = false
  let isExists1 = false
  let isExists2 = false
  hands.forEach(() => {
    hand = janken.choiceCpuHand()
    switch(hand){
      case 0:
        isExists0 = true
        break
      case 1:
        isExists1 = true
        break
      case 2:
        isExists2 = true
        break
      default:
        throw new Error('choiceCpuHand が想定外の値を出しました');
    }
  })
  expect(isExists0).toBe(true)
  expect(isExists1).toBe(true)
  expect(isExists2).toBe(true)
})
```

そういえば。 `switch` 構文の説明をしていなかった。

```javascript
switch(value){ // 判定したい値を書く
  case 0: // 値 value がこの値の時の処理を書く
    isExists0 = true
    // 処理はいっぱい書ける
    break // 最後にこの文言を入れる
  case 1:
    isExists1 = true
    break
  case 2:
    isExists2 = true
    break
  default: // どの値にも該当しなかった場合の処理をこの後に書く
    throw new Error('choiceCpuHand が想定外の値を出しました');
}
```

`switch(/*判定したい値*/)` と書いて、その後に値毎に処理したいコードを書く。 `if(){ ... }else` を連ねた物のかわりとして使うと見通しが良い。

ちなみに `throw` とは「例外」を投げる構文である。これはプログラムが異常な行動を起した事を明示的に伝える手段である。

さて、さっきのテストコードに戻ろう。

```JavaScript
const janken = require('../janken') // インポート元のファイルは相対パスで書かなければいけないためこうなる。

test('choiceCpuHand', () => {
  let hands = new Array(100) // 要素100の配列を用意する
  hands.fill(0) // なんでもいいので値を埋める
  let isExists0 = false // フラグを定義する
  let isExists1 = false
  let isExists2 = false
  // handsの要素文だけ以下を実行する。つまり100回実行される
  hands.forEach(() => {
    hand = janken.choiceCpuHand() // 関数を実行する
    switch(hand){
      case 0: // 0が出てきたら
        isExists0 = true // フラグを立てておく
        break
      case 1: // 同様
        isExists1 = true
        break
      case 2:
        isExists2 = true
        break
      default: // 0,1,2 以外の値を返したら例外を投げる。
        throw new Error('choiceCpuHand が想定外の値を出しました');
    }
  })
  expect(isExists0).toBe(true) // 途中で0が出てきたか確認する。以下同様。
  expect(isExists1).toBe(true)
  expect(isExists2).toBe(true)
})
```

さて、テストができたのでテストをしよう。

```bash
> npm test

> janken@0.1.0 test
> jest

 FAIL  test/janken.test.js
  × choiceCpuHand (3 ms)

  ● choiceCpuHand

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      24 |     }
      25 |   })
    > 26 |   expect(isExists0).toBe(true)
         |                     ^
      27 |   expect(isExists1).toBe(true)
      28 |   expect(isExists2).toBe(true)
      29 | })

      at Object.<anonymous> (test/janken.test.js:26:21)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 total
Snapshots:   0 total
Time:        0.371 s, estimated 1 s
Ran all test suites.
```

失敗した。当然だ。`choiceCpuHand`はいま1しか返してこない。
このように **まずテストを作ってこれを合格するように関数を実装する** というのが「テスト先行開発」である。

####  8.3.7. <a name='関数の実装'></a>関数の実装

さて、今 `janken.js` にはこれしか書いていない。

```JavaScript
const choiceCpuHand = () => {
  return 1
}

module.exports = {
  choiceCpuHand
}
```

これを具体的に実装するとこうなる。

```JavaScript
const choiceCpuHand = () => {
  let hand = Math.floor(Math.random()*3)
  return hand
}

module.exports = {
  choiceCpuHand
}
```

`Math` というのは数学関連の関数が入ってるライブラリである。これは npm パッケージではなく JavaScript の標準ライブラリなのでインポートの必要が無い。
[`Math.random()`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Math/random) は0以上1未満の値をランダムで返す関数である。 [Math.floor()](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Math/floor) は与えられた値 **以下** の整数を返す関数である。(つまりマイナスの値は方向に丸められる)

まぁ実装してしまえばなんてことはなく1行ですんでしまったのだが、それでも **明確な機能を持った単位は分離する** という考えかたはとても重要である。
分離しておけばテストも実行できる。さて先程のテストをまた実行してみよう。

```bash
> npm test

> janken@0.1.0 test
> jest

 PASS  test/janken.test.js
  √ choiceCpuHand (2 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        0.356 s, estimated 1 s
Ran all test suites.
```

どうやら通った。いいかんじである。

####  8.3.8. <a name='実装を進める上で'></a>実装を進める上で

さて、今度は「コンピュータの手と入力された手を判定して勝敗を返す」という関数を作らなければいけない。
先程と同様に「ガワ」だけ書こう。入力はどうするべきか、出力はどうするべきか、それを考えながら関数を書いていく。思い出してほしい。関数でまず決めるのは「入力と出力」である。つまり **型** である。

```JavaScript
const choiceCpuHand = () => {
  let hand = Math.floor(Math.random()*3)
  return hand
}

const judgeJankenHand = (playerHand, cpuHand) => {
  return 0
}

module.exports = {
  choiceCpuHand,
  judgeJankenHand
}
```

関数が増えてきたので説明を書いておきたい。関数の上にキャレットを持っていき、 `/**` と入力しエンターを押そう。こんなコードが補完されるはずだ。

```JavaScript
const choiceCpuHand = () => {
  let hand = Math.floor(Math.random()*3)
  return hand
}

/**
 * 
 * @param {*} playerHand 
 * @param {*} cpuHand 
 * @returns 
 */
const judgeJankenHand = (playerHand, cpuHand) => {
  return 0
}

module.exports = {
  choiceCpuHand,
  judgeJankenHand
}
```

これは「 [JSDoc](https://ja.wikipedia.org/wiki/JSDoc) 」と呼ばれるもので、関数の説明を書く時に使われる構文である。全体としてコメントであるためコードの動作には寄与しないが、
IDEで見た時にここに書いた説明を表示してくれたりパッケージのドキュメントの自動生成に使われたりする。できるだけ書いておこう。

そもそも「どの数字がどの手か」とか、「勝敗はどんな数値で表されるか」とか、そのあたりとかがぼんやりとしか決まっていない。
仕様を明確にするためにもこういったメモを残したり、なんでもない数値でも定数として定義したりするのが大事である。
なのでこれらのコードにちょっとコメントや定数を書き足していく。

> 数字に意味を持たせたものを数字のまま書く事は「マジックナンバー」と言われコードの可読性を低めるという意味でよくないものとされている。

```JavaScript
/**
 * じゃんけんで用いられる手
 */
const hands = {
  /** グー */
  rock: 0,
  /** チョキ */
  scissors: 1,
  /** パー */
  paper: 2
}

/**
 * じゃんけんの勝敗
 */
const decided = {
  /** プレイヤーの勝ち */
  win: 1,
  /** プレイヤーの負け */
  lose: -1,
  /** あいこ */
  draw: 0
}

/**
 * ランダムにCPUの手を生成する。
 * @returns 0:グー、1:チョキ、2、パー をランダムに返す
 */
const choiceCpuHand = () => {
  let hand = Math.floor(Math.random()*3)
  return hand
}

/**
 * プレイヤーの手とCPUの手を比べて勝敗を返す
 * @param {Number} playerHand プレイヤーの手
 * @param {Number} cpuHand CPUの手
 * @returns 勝敗 desiced
 */
const judgeJankenHand = (playerHand, cpuHand) => {
  return decided.draw
}

module.exports = {
  choiceCpuHand,
  judgeJankenHand,
  hands,
  decided
}


```

適当な場所にこれらの関数や定数をうちこもうとしてみるといい。ちゃんと書いた説明が表示されるだろう。このようにコードにコメントを残すのはとても重要である。

さて、今度は `judgeJankenHand` のテストを書いていく。これはきちんと考えなければいけない事が多い。

* プレイヤーが勝ちのパターン
* プレイヤーが負けのパターン
* あいこのパターン
* 定義されていない手が入力されたパターン

どうせふたりのじゃんけんなのでパターンは高々9通りしか無い。全てのパターンについて書いてしまうのがいいだろう。
とはいえ全てのパターンに対してテストを書くのはちょっとしんどい。なにかいいものはあるだろうか。 **ある** 。

[`test.each()`](https://jestjs.io/ja/docs/api#testeachtablename-fn-timeout) というものが用意されている。これは渡す値と結果の値を書けばテストをそれぞれ実行してくれるものだ。
サイトに書いてある使用例のうち一つをを以下に引用する。これが一番わかりやすいだろう。

> ```JavaScript
> test.each([
>   {a: 1, b: 1, expected: 2},
>   {a: 1, b: 2, expected: 3},
>   {a: 2, b: 1, expected: 3},
> ])('.add($a, $b)', ({a, b, expected}) => {
>   expect(a + b).toBe(expected);
> });
> ```

やってる事が数段階あるので丁寧に分解しながら解説する。

```JavaScript
test.each([
  {a: 1, b: 1, expected: 2},
  {a: 1, b: 2, expected: 3},
  {a: 2, b: 1, expected: 3},
])
```

この部分全体が「渡された変数に従ってテストを実行する関数」を返す。 `test.each()` 全体が関数となるので、(これを仮に `t` としよう。)次に書いてある引数に従ってテストを実行する。

```JavaScript
t('.add($a, $b)', ({a, b, expected}) => {
  expect(a + b).toBe(expected);
});
```

`test.each()` が返してくる関数は渡された配列オブジェクトを元に第1引数のメッセージを補完し、第2引数のテスト本体を実行する。

ちなみに下記のような書き方をすると関数は渡されたオブジェクトの中身を直接参照できる。上記のテストメソッドはその方式で書かれている。

```JavaScript
let obj = {
  value: 10,
  message: 'hello'
}

f = function({message}){
  console.log(message)
}

f(obj) // hello と表示される
```

という訳でこのメソッドをつかってテストを書こう。

```JavaScript
test.each([
  { p: janken.hands.rock,     c: janken.hands.rock,     expected: janken.decided.draw },
  { p: janken.hands.rock,     c: janken.hands.paper,    expected: janken.decided.lose },
  { p: janken.hands.rock,     c: janken.hands.scissors, expected: janken.decided.win  },
  { p: janken.hands.paper,    c: janken.hands.rock,     expected: janken.decided.win  },
  { p: janken.hands.paper,    c: janken.hands.paper,    expected: janken.decided.draw },
  { p: janken.hands.paper,    c: janken.hands.scissors, expected: janken.decided.lose },
  { p: janken.hands.scissors, c: janken.hands.rock,     expected: janken.decided.lose },
  { p: janken.hands.scissors, c: janken.hands.paper,    expected: janken.decided.win  },
  { p: janken.hands.scissors, c: janken.hands.scissors, expected: janken.decided.draw }
])('自分の手 : $p 、相手の手 : $c', ({p, c, expected}) => {
  expect(janken.judgeJankenHand(p, c)).toBe(expected)
})

test.each([
  { p: 4,  c: janken.hands.rock},
  { p: -1, c: janken.hands.rock},
  { p: janken.hands.rock, c: 4 },
  { p: janken.hands.rock, c: -1}
])('自分の手 : $p 、相手の手 : $c (例外検知)', ({p, c}) => {
  expect(() => {janken.judgeJankenHand(p, c)}).toThrow()
})
```

通常のパターンは高々9パターンしか無いので全部書き出した(こういう「普通の動きをする予定のテスト」を「正常系」と呼ぶ)。それと異常値を検出した場合は例外が投げられる事にする(こういう「想定外の引数や状態を検査するテスト」を「異常系」と呼ぶ)。 `.toThrow()` は例外が投げられる事を検知するアサーションだ。

> このように jest には様々な方法のテストやアサーションをするためのメソッドが用意されている。是非 jest の [全体](https://jestjs.io/ja/docs/api) や [Expect](https://jestjs.io/ja/docs/expect) のページを眺めてどんなテストができるか見てみよう。

さて、このままだともちろんテストは失敗する。テストが通るように関数を実装していこう。
テストが実装されているので、逆に言えば関数の実装自体はテストが通ればなんでもいい。なぜならテストは仕様でありテストの結果が全てであるからである。
だからこそテストは厳密に書く必要があり要件を漏らしてはいけない。

----

演習 : これまで学んできた事で十分にこの関数は実装できる。関数 `judgeJankenHand` の実装を完成させよ。

----

> 十分なものが書けたと思ったら `npm test` のかわりに `npm test -- --coverage` と入力してテストを実行してみよう。「カバレッジ」というものが表示される。これはテストの結果テスト対象のうち実行されたコードがどのくらいあるかを示すものだ。もしテストが正常に通っているのにコード内に実行されていない行があったとすればそれはテストが不十分かデッドコード(必要の無い無駄なコード)があるかのどちらかである。とはいえ大きなプロジェクトでは完璧なテストを書くのがそもそも難しく通常カバレッジは 80% 以上程度あれば上々とされる。

そうしたら後は勝敗を出して、続けるかどうかを聞きたらそれにそってループ条件となるフラグを操作するだけである。最初にやった事とおなじような事しかしないので詳細は割愛し、完成した `index.js` の例を以下に示す。変数名等は見やすく変えているところもある。

```JavaScript
const inquirer = require('inquirer')
const janken = require('./janken')

const hands = [
  { name: 'グー', value: 0 },
  { name: 'チョキ', value: 1 },
  { name: 'パー', value: 2 },
]

const questionHand = {
  type: 'list',
  name: 'hand',
  message: 'あなたの手は？',
  choices: hands
}

const questionContinue = {
  type: 'list',
  name: 'continue',
  message: '続ける？',
  choices: [
    { name: '続ける', value: true },
    { name: 'やめる', value: false }
  ]
}

;(async () => {
  //  くりかえし
  let flag = true
  while(flag){
    // プレイヤーの手をうけとる
    let answerHand = await inquirer.prompt([
      questionHand
    ])
    // コンピュータの手を決める
    let cpuHand = janken.choiceCpuHand()
    console.log(hands[cpuHand].name + '!')
    // 勝敗を求める
    let judge = janken.judgeJankenHand(answerHand.hand, cpuHand)
    // 勝敗を出す
    switch(judge){
      case janken.decided.win:
        console.log('あなたの勝ち！')
        break
      case janken.decided.lose:
        console.log('あなたの負け！')
        break
      case janken.decided.draw:
        console.log('あいこ！')
    }
    // 再戦するかを聞く
    let answerContinue = await inquirer.prompt([
      questionContinue
    ])
    flag = answerContinue.continue
  }
  // くりかえしおわり
})()
```

単純なプログラムだが初歩に必要な事はこれらのプログラムに大体詰っている。基本的な制御構文、関数、機能のライブラリ化、そしてテスト。おめでとう！これでプログラムの大きな一歩を踏み出せた！
